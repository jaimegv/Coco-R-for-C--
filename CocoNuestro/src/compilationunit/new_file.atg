// Set the name of your grammar here (and at the end of this grammar):
COMPILER CEMASMAS

// Add auxiliary methods and declaration here.
	// Declaracion de constantes para tipos
	final int undef=0, entera=1, bool=2, cadena=3;
	// Declaración de constantes de tipo de scopes
	final int var=0, funcion=1, clase=2, metodo=3;

	// Tabla de simbolos global
//	public TablaSimbolos tabla;

// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit.
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.
  letter2		= 'A' .. 'Z' + 'a' .. 'z' + '_'.

  c1 			= ANY - "\"".
  c3 			= 'A' .. 'Z' + 'a' .. 'z' + '_' + digit.
  c4			= ANY - cr.
  c5			= ANY - "*".
  c6 			= ANY - "/".

TOKENS
  ident = letter { letter2 | digit }.


  enteros = ( zero | nonZeroDigit { digit }).
  
  cadenaCar = "\"" { c1 } "\"".


  bool = "boolean".
  boool = "bool".
  charr    = "char".
  classs   = "class".
  false   = "false".
  intt     = "int".
  new     = "new".
  short   = "short".
  static  = "static".
  true    = "true".
  voidd    = "void".
  publicc = "public".
  privatte = "private".
  dospuntos_dos = "::".
  rreturn = "return".
  cout = "cout".
  cin = "cin".
  menor_menor = "<<".
  mayor_mayor = ">>".
  iff = "if".
  elsse = "else".
  main = "main".
  
  
  dosPuntos   = ":".
  comma   = ",".
  punto     = ".".
  llave_ab  = "{".
  corchete_ab  = "[".
  parent_ab    = "(".
  op_menos   = "-".
  op_menosmenos   = "--".  

  op_mas    = "+".
  op_masmas = "++".
  llave_ce  = "}".
  corchete_ce  = "]".
  parent_ce    = ")".
  op_producto	= "*".
  op_division		= "/".

  op_asig           = "=".
  puntoComa			= ";".
  doblesComillas	= '"'.
  interrogacion		= "?".
  barra_vert = "|".

  op_negacion    = "!".
  op_menor	   	 = "<".
  op_mayor		 = ">".
  op_menor_igual = "<=" .
  op_mayor_igual = ">=" .
  op_igual			= "==".
  op_distinto = "!=".
  op_and = "&&".
  op_or = "||".
  
  op_asig_mas = "+=".
  op_asig_menos = "-=".
  op_asig_producto = "*=".
  op_asig_division = "/=".
  op_asig_modulo = "%=".
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab



//PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .


// Punto de entrada del codigo fuente, acabará SIEMPRE en un MAIN
CEMASMAS (. int type=undef; 
			int type1;.)  
=
	DecClase CEMASMAS
			 | ((Ttipo<out type> | voidd) 
			 		(Main | ident (Subprograma | DecVar<out type1> (. 	if (type1==type) {
			 																//System.out.println("tipos ok!"+type+" "+type1);
		 																}
																		else if (type1==undef) {
																			//System.out.println("tipos ok!__No has inicializado la var, pero ok!");
																		} 
																		else {
																			SemErr("Del error de arriba->Tipos distintos "+type+" y " + type1);
																		} .) 
								| DecMetodo) CEMASMAS))
.

Ttipo<out int type>	// Devolvemo un entero con el tipo
= 				(.	type = undef; //inicializamos
				.)
(	intt		(. type = entera;	.)	
	| bool		(. type = bool; 	.)	// Entendemos que estos dos
	| boool		(. type = bool; 	.)	// son el mismo tipo		
	| charr [op_producto] 	(. type = cadena; .)
).


DecClase	(. int type; .) // Dec Variable
=
[publicc | privatte] classs ident llave_ab 
							Cuerpo_Clase
							[(publicc dosPuntos Cuerpo_Clase [privatte dosPuntos Cuerpo_Clase])
							| (privatte dosPuntos Cuerpo_Clase [publicc dosPuntos Cuerpo_Clase])]		
								  llave_ce puntoComa.

Cuerpo_Clase	(. int type; .) // Dec Variable 
= [{(Ttipo<out type> ident (DecVar<out type> | DecCabMet))
							  | voidd ident DecCabMet}].


DecCabMet	(. int type; .) 
= parent_ab Param_Cab parent_ce puntoComa
.

Param_Cab = (. int type; .) 

	[Ttipo<out type> [Vector] [{comma Ttipo<out type> [Vector]}] | voidd]
.

DecMetodo = dospuntos_dos ident parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.

Main = main parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.

Cuerpo 	(. int type; .) 
=
	{Instruccion 
		| (Ttipo<out type>|voidd) ident (Subprograma | ([Vector] DecVar<out type> [op_asig (ident | enteros | cadenaCar)]))}
.


//El apéndice del final indica el nivel de anhidamiento.

DecVar <out int type>
= (. int type1=undef;.)
[op_asig Expresion<out type1>] puntoComa	(.	type=type1;.)
.

Parametros	(. int type; .) 
=
	Ttipo<out type>ident [Vector] [{comma Ttipo<out type>ident [Vector]}] | voidd
.

Vector = corchete_ab [Expresion_Entera] corchete_ce.

Subprograma = parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.


/******************INSTRUCCIONES*****************************/
Instruccion = InstReturn | InstCout | InstCin | InstExpresion | InstIfElse.

InstExpresion
=	(. int type=undef; .)
		ident[punto ident] ((parent_ab Argumentos parent_ce puntoComa)
				| ((op_asig | op_asig_mas | op_asig_menos |
					op_asig_producto | op_asig_division | op_asig_modulo) 
													Expresion<out type> puntoComa))
.

InstReturn
=	(. int type=undef; .)
(rreturn [Expresion<out type>] puntoComa)
.

/****************************************************/

InstIfElse	(. int type;
				int type1; .) 
=
	iff Expresion<out type> ((llave_ab Cuerpo llave_ce) | (Instruccion | Ttipo<out type>ident (Subprograma | ([Vector] DecVar<out type> [op_asig (ident | enteros | cadenaCar)])))) [Else]
.

Else	(. int type; .) 
=
	elsse ((llave_ab Cuerpo llave_ce) | (Instruccion | Ttipo<out type>ident (Subprograma | ([Vector] DecVar<out type> [op_asig (ident | enteros | cadenaCar)]))))
.

/***************************************************/


/******************PRINT***********************/


InstCout = cout {menor_menor Arg_io} puntoComa.

InstCin = cin mayor_mayor Arg_io puntoComa.

Arg_io = ident [Vector] | cadenaCar.



/******************EXPRESIONES*****************************/
/*
Expresion<out int type> 
= (. type=undef; .)
(	enteros (.	type=entera;	.)
	| cadenaCar (.	type=cadena;	.)
	| true	(.	type=bool;	.)
	| false	(.	type=bool;	.)
).
*/
Expresion <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
 = Expresion2 <out type> Expresion1	<out type1>	(.	if (type==type1) {
 														tipoDev=type;
 														//System.out.println("expresion!"+type);
 													} else if (type1==undef) {
 														tipoDev=type;
 													} else {
 														SemErr("Error en Expresion");
 													}
												.)
.

Expresion1 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1, type2; 
.)
= ["?" Expresion<out type>":" Expresion <out type1> Expresion1 <out type2>]
.

Expresion2 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= Expresion3 <out type> Expresion21 <out type1> (.  if (type1==undef) {	// no hay segunda parte expr
														tipoDev=type;
													} else if (type1==entera) {	// Expresion con op_relacional
														if (type==type1) {
															tipoDev=entera;		// op_relacional ok!
														} else {
															SemErr("Operando relacional incorrecto.");
														}
													} else if (type1==bool) {	// Expresion con op_logico
														if (type==type1) {
															tipoDev=bool;	// op_logico ok!
														} else {
															SemErr("Operando logico incorrecto.");
														}
													} else {
														SemErr("Operacion Expr2 problems"+type+" "+type1);
													}
												.)
.

Expresion21 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= [Operador_Logico Expresion3 <out type> Expresion21 <out type1> (.	if (type==bool) {
																		if (type1==undef) {	// todo ok!
																			tipoDev=type;
																		} else if (type1==bool) {	//2º ok!
																			tipoDev=type;
																		} else {				// 2º arg problem
																			SemErr("OpLogico Error:"+type);
																		}
//																	} else if ((type==bool) && (!(type==type1))) {
//																		SemErr("Op logico con tipo_arg diferentes"+type+" "+type1);
//																	} else if (type==entera) {
//																		SemErr("Op logico con arg entero:"+type);
																	} else {	// error en 1º arg
																		tipoDev=type;	// lo envio para q salte el error
																		SemErr("OpLogico Error:"+type);
																	}
																.)]
| [Operador_Relacional Expresion3 <out type> Expresion21 <out type1> (.	if ((type==entera) && (type1==undef)) {
																		tipoDev=type;
																	} else if ((type==entera) && (!(type==type1))) {
																		SemErr("Op Relacional con tipo_arg diferentes"+type+" "+type1);
																	} else {
																		tipoDev=type1;
																	}
																.)
												]
.

Expresion3 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= Expresion4 <out type> Expresion31 <out type1> (. 	if (type1==undef) {
														tipoDev=type;
													} else if ((type==type1) && (type1==entera)) {
														tipoDev=type;
													} else {
														SemErr("Operacion Arit sobre tipos no enteros");
													}
												  .)
.

Expresion31 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= [Operador_Aritmetico Expresion4 <out type> Expresion31 <out type1> (. if (type1==undef) {	// No hay 2º parte
																			if (type==entera) {	// todo ok!
																				tipoDev=type;
																			} else {			// NO es un tipo ENTERO
																				SemErr("Operacion Arit con arg no entero");
																			}
																		} else {	// hay otro expresion
																			if ((type==type1) && (type==entera)) {	// las dos son enteras
																				tipoDev=type;
																			} else {
																				SemErr("Operacion Arit sobre tipos no enteros");
																			}
																		}
																	  .)
																	]
.

Expresion4 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1, type2;
.)
= op_negacion Expresion4 <out type> (.	if (type==bool) {
											tipoDev=type;
										} else {
											SemErr("Estas negando un tipo NO bool");
										}
									.)
| op_menos Expresion4<out type1>	(.	if (type1==entera) {
											tipoDev=type1;
										} else {
											SemErr("Estas negando un tipo NO entero");
										}
									.)
| Expresion5 <out type2> (. tipoDev=type2; .)
.

/* Expresion 5 recoge todos los siguientes supuestos:

			Constructor
			ident
			ident.ident
			ident (Argumentos)
			enteros
			Todas aquellas Expresiones que contienen los siguientes operadores
					
							Aritméticos (+)
							Relación    (<)
							Lógicos   	(!)  
							Asignacion 	(=)
							Condicional
							Acceso a miembros de una clase (.)
							Acceso a un vector ([])
*/


Expresion5 <out int tipoDev> 
(.  tipoDev=undef;
	int type1, type;
.)
= 
"(" Expresion <out type1> ")"	(. tipoDev=type1; .)
| "new" ident "("Argumentos")"       /*Constructor*/
| ident ["."ident ["("Argumentos")"] | "("Argumentos")"| "["Expresion <out type> "]" (. tipoDev=type;.)]
| enteros		(. tipoDev=entera;	.)
| cadenaCar		(. tipoDev=cadena;	.) 
| "true"		(. tipoDev=bool;	.)
| "false"		(. tipoDev=bool;	.)
.

Expresion_Entera = (enteros | ident) [Operador_Aritmetico Expresion_Entera]
					| parent_ab Expresion_Entera parent_ce [Operador_Aritmetico Expresion_Entera]
.

/**********************************************************/

Argumentos
=	(. int type=undef; .)
[Expresion<out type> {"," Argumentos}]
.


Operador_Aritmetico = op_mas | op_menos | op_producto | op_division
.

Operador_Logico = op_or | op_and | op_negacion
.
				
Operador_Relacional = op_menor | op_mayor |   op_menor_igual
				| op_mayor_igual | op_igual | op_distinto
.

END CEMASMAS.