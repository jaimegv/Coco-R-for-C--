import java.util.Vector;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.Queue;

// Set the name of your grammar here (and at the end of this grammar):
COMPILER CEMASMAS1
//	import java.util.*;
// Add auxiliary methods and declaration here.
	// Declaracion de constantes para tipos
	final int undef=0, entera=1, bool=2, cadena=3, vacio=4, identificador=5;
	// Declaración de constantes de tipo de scopes
	final int var=0, funcion=1, clase=2, metodo=3, parametro=4;
	//Declaración de visibilidad
	final int privado=0, publico=1;

	// Tabla de simbolos global
	public Tablas tabla;
	// Tupla devuelta por las expresiones (tipo, valor)

// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit.
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.
  letter2		= 'A' .. 'Z' + 'a' .. 'z' + '_'.

  c1 			= ANY - "\"".
  c3 			= 'A' .. 'Z' + 'a' .. 'z' + '_' + digit.
  c4			= ANY - cr.
  c5			= ANY - "*".
  c6 			= ANY - "/".

TOKENS
  ident = letter { letter2 | digit }.


  enteros = ( zero | nonZeroDigit { digit }).
  
  cadenaCar = "\"" { c1 } "\"".


  bool = "boolean".
  boool = "bool".
  charr    = "char".
  classs   = "class".
  false   = "false".
  intt     = "int".
  new     = "new".
  short   = "short".
  static  = "static".
  true    = "true".
  voidd    = "void".
  publicc = "public".
  privatte = "private".
  dospuntos_dos = "::".
  rreturn = "return".
  cout = "cout".
  cin = "cin".
  menor_menor = "<<".
  mayor_mayor = ">>".
  iff = "if".
  elsse = "else".
  main = "main".
  
  
  dosPuntos   = ":".
  comma   = ",".
  punto     = ".".
  llave_ab  = "{".
  corchete_ab  = "[".
  parent_ab    = "(".
  op_menos   = "-".
  op_menosmenos   = "--".  

  op_mas    = "+".
  op_masmas = "++".
  llave_ce  = "}".
  corchete_ce  = "]".
  parent_ce    = ")".
  op_producto	= "*".
  op_division		= "/".

  op_asig           = "=".
  puntoComa			= ";".
  doblesComillas	= '"'.
  interrogacion		= "?".
  barra_vert = "|".

  op_negacion    = "!".
  op_menor	   	 = "<".
  op_mayor		 = ">".
  op_menor_igual = "<=" .
  op_mayor_igual = ">=" .
  op_igual			= "==".
  op_distinto = "!=".
  op_and = "&&".
  op_or = "||".
  
  op_asig_mas = "+=".
  op_asig_menos = "-=".
  op_asig_producto = "*=".
  op_asig_division = "/=".
  op_asig_modulo = "%=".
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab



//PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
CEMASMAS1 (.	tabla = new Tablas();	.)  //Se crea el ámbito global
= CEMASMAS
.

// Punto de entrada del codigo fuente, acabará SIEMPRE en un MAIN
CEMASMAS
(.	int type=undef; 
	int type1;
.)
=
	DecClase CEMASMAS
			 | ((Ttipo<out type>	// Existe este tipo ident¿?
			 						(.	System.out.println("Hola!"+t.val);
			 							if (type==identificador) {
											Simbolo simbolo = new Simbolo(t.val, type, 0);
											simbolo.SetLine(t.line);
											simbolo.SetColumn(t.col);
											
											if (tabla.EstaEnActual(simbolo.GetNombre())) {
												tabla.InsertarEnActual(simbolo);
											} else {
												SemErr(t.val + " No declarado anteriorment");
											}
										}
			 						.)
			 			| voidd | ident	(.	// En caso de declarar un Objeto de una clase
			 										   Simbolo simbolo = new Simbolo(t.val, type, 0);
							 						   simbolo.SetLine(t.line);
							 						   simbolo.SetColumn(t.col);

							 						   if (tabla.EstaEnActual(simbolo.GetNombre())) {
							 						   		Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
							 						   		SemErr(simbolonuevo.GetNombre() + " ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
							 						   	} else {
							 							   tabla.InsertarEnActual(simbolo);
														}
	 											.)	) //Parentedid de Ttipo|voidd|ident
			 			(Main <type>
			 				| ident  	
			 						(. Simbolo simbolo = new Simbolo(t.val, type, 0);
			 						   simbolo.SetLine(t.line);
			 						   simbolo.SetColumn(t.col);
			 						   System.out.println("Entraste en ident");
			 						   
			 						   Simbolo sim = tabla.GetSimboloRecur(t.val);
			 						   // Metodo de una clase: Persona::daAnio
			 						   if (la.val.equals((String) "::")) { // casting, si el siguiente es metodo, caso especial
			 						   		if (tabla.EstaEnActual(simbolo.GetNombre())		// Existe
			 						   					&& (sim!=null) && (sim.GetKind()==clase)) {	// y es de tipo clase
			 						   			System.out.println("Metodo de una clase existente!(Clase:"+simbolo.GetNombre()+"), todo ok!");
			 						   		} else {
			 						   			SemErr("No existe la clase: "+t.val);
			 						   		}
			 						   } else if (tabla.EstaEnActual(simbolo.GetNombre())) {
			 						   		Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
			 						   		SemErr(simbolonuevo.GetNombre() + " ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
										} else {
											//SemErr("No existe ningún objeto "+simbolo.GetNombre()+" creado.");
											tabla.InsertarEnActual(simbolo); // Estaba puesto antes...
										}
			 						.)
			 					  	( (. System.out.println("Entras a Subprograma"); .)
			 					  	 Subprograma <simbolo>
			 					  		| Vector<simbolo> puntoComa 
			 					  			| DecVar<out type1, simbolo> 
		 					  											(. 
		 					  											if (type1==type) {
			 																//System.out.println("tipos ok!"+type+" "+type1);
		 																}
																		else if (type1==undef) {
																			//System.out.println("tipos ok!__No has inicializado la var, pero ok!");
																		} 
																		else {
																			SemErr("Tipos: Error: arg1="+type+",arg2=" + type1);
																		}
																		//System.out.println("El valor del simbolo es:"+simbolo.GetValor()); 
																		.)
												| DecMetodo (.System.out.println("Entraste en metodo"); .)
									)
								CEMASMAS))
.

Ttipo<out int type>	// Devolvemo un entero con el tipo
= 				(.	type = undef; //inicializamos
				.)
(	intt		(. type = entera;	.)	
	| bool		(. type = bool; 	.)	// Entendemos que estos dos
	| boool		(. type = bool; 	.)	// son el mismo tipo		
	| charr [op_producto] 	(. type = cadena; .)
	| ident		(. type = identificador; .)	// tipo identificador	
).

//******************************************************************//


DecClase	(. int type;
				int visible=privado; .) // Visibilidad del contenido, por defecto PRIVADO
= (. Simbolo simbolo = new Simbolo ("undef", 0, clase); System.out.println("DecClase!");.)
	[publicc (. simbolo.SetVisibilidad(1); .) 
		| privatte (. simbolo.SetVisibilidad(0); .)]
 	classs ident (. simbolo.SetNombre(t.val);	// Modifico el nombre del Simbolo
					simbolo.SetLine(t.line);
					simbolo.SetColumn(t.col);
					if ((tabla.EstaEnActual(t.val)) &&
							(tabla.GetSimboloRecur(t.val) != null) &&
								(tabla.GetSimboloRecur(t.val).GetKind()==clase) ) {
						SemErr("Clase "+ t.val +" ya definida en línea "+tabla.GetSimboloRecur(t.val).GetLine()+
									" y columna:"+ tabla.GetSimboloRecur(t.val).GetColumn());
				.)
					{ANY (. System.out.println("Imprimiendo ANY!"+t.val); .)} | llave_ce puntoComa
				(.		
					} else {	// Nueva clase!
						tabla.InsertarEnActual(simbolo);
						tabla.NuevoAmbito();		// Nuevo ambito para meter metodos
				.)
			llave_ab	// y variables de la clase.
				Cuerpo_Clase<visible>
							[(publicc dosPuntos Cuerpo_Clase<visible> [privatte dosPuntos Cuerpo_Clase<visible>])
							| (privatte dosPuntos Cuerpo_Clase<visible> [publicc dosPuntos Cuerpo_Clase<visible>])]						 
				(.		
						tabla.CerrarAmbito();
					}	// fin else, para el ambito de nua clase OK! 
				.)
			llave_ce
	puntoComa
.

Cuerpo_Clase <int visible>
	(.	int type;
	.)	// Recuerda! estas en un ambito clase 
= [{(Ttipo<out type> ident (. 	Simbolo sim = new Simbolo(t.val, 0, 0);	// Creacion del simbolo
								sim.SetVisibilidad(visible);
								sim.SetLine(t.line);
	 						    sim.SetColumn(t.col);
								tabla.InsertarEnActual(sim);
							.)
						( 	(. /* Caso en que es una Declaracion de variable */
								sim.SetKind(var);	// Es variable
								sim.SetType(type);	// Su tipo
							.) 
								DecVar<out type, sim> 
							| (./* Caso Declaracion Cabecera de un metodo */
								sim.SetKind(metodo);
								sim.SetTipoRetorno(type);
								.)
								DecCabMet<sim> ))
							  | (.Simbolo sim = new Simbolo(t.val, 0, 0);.) voidd ident DecCabMet<sim>}]
.


DecCabMet<Simbolo simbolo>
	(. int type; .) 
= parent_ab Param_Cab parent_ce puntoComa
.

Param_Cab = (. int type;
			   Simbolo sim = new Simbolo("Temo",0,0);
			   .) 
	[Ttipo<out type> [Vector<sim>] [{comma Ttipo<out type> [Vector<sim>]}] | voidd]
.

DecMetodo 
= (. Simbolo sim = new Simbolo("no def", 0, 0);		// Añado metodo al ambito actual
	 System.out.println("Estas en declaracion Metodo");
.) 
	dospuntos_dos ident	(.	System.out.println("Comprobando si el metodo-"+la.val+" pertenece a la clase");
/*							if ((tabla.EstaEnActual(t.val)) &&
								(tabla.GetSimboloRecur(t.val) != null) &&
									(tabla.GetSimboloRecur(t.val).GetKind()==clase) ) {
*/
						.) 
		parent_ab 
			[Parametros<sim>]
		parent_ce 
		llave_ab 
			Cuerpo 
		llave_ce
.



//******************************************************************//
Main<int type> = (. Simbolo simbolo = new Simbolo("main",type,funcion);.)
	   main   (.tabla.NuevoAmbito();
			  simbolo.SetKind (funcion);
			  simbolo.SetTipoRetorno(simbolo.GetType());.)   
	   parent_ab [Parametros <simbolo>] parent_ce llave_ab Cuerpo llave_ce
.

Cuerpo 	(. int type = undef; .) 
=
	{Instruccion 
		| (Ttipo<out type>|voidd) ident (.Simbolo simbolo = new Simbolo(t.val, type, 0);
			 						 	  simbolo.SetLine(t.line);
			 						   	  simbolo.SetColumn(t.col);
			 						   
			 						   	  if (tabla.EstaEnActual(simbolo.GetNombre()))
			 						   			{
			 						   			Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
			 						   			SemErr(simbolonuevo.GetNombre() + " ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
			 						   			}
			 						   	  else
			 						   	  		{
			 							   		tabla.InsertarEnActual(simbolo);
			 							   		}	
			 							   	.) 
			(Subprograma <simbolo>
		 | (Vector<simbolo> puntoComa | DecVar<out type, simbolo> ))}
.


//El apéndice del final indica el nivel de anhidamiento.

DecVar <out int type, Simbolo simbolo>
= (. int type1=undef;
//System.out.println("Estas en DecVar");
.)
[op_asig Exp<out type1, simbolo> (. System.out.println("Variable inicializada a " + simbolo.GetValor()); .)
					] puntoComa	(. type=type1; .)//Expresion<out type1, sim>] puntoComa	(.	type=type1;.)
.


Parametros <Simbolo simbolo_nombre_funcion>	(. int type; .) 
= 	Ttipo<out type>ident (. Simbolo simbolo_parametro = new Simbolo(t.val, type, parametro);
							simbolo_parametro.SetLine(t.line);
							simbolo_parametro.SetColumn(t.col);
							simbolo_nombre_funcion.AnadirParametro(simbolo_parametro);
							tabla.InsertarEnActual(simbolo_parametro); .) 
				[Vector <simbolo_parametro>]
				[{comma Ttipo<out type>ident (. simbolo_parametro = new Simbolo(t.val, type, parametro);
												simbolo_nombre_funcion.AnadirParametro(simbolo_parametro);
												tabla.InsertarEnActual(simbolo_parametro);.) 
				[Vector <simbolo_parametro>]
				}] 
				| voidd
.

Vector <Simbolo simbolo> = (. simbolo.SetToVector();
							  Simbolo sim = new Simbolo ("Temp", 0,0);
							  int type;.)
corchete_ab [Exp <out type, sim> (. ((Number)sim.GetValor()).intValue();
											 System.out.println("El tamano del vector es " + (Number)sim.GetValor());.)
] corchete_ce.


//*************SUBPROGRAMA**********************************//




Subprograma <Simbolo simbolo> = (.  tabla.NuevoAmbito();
									simbolo.SetKind (funcion);
									simbolo.SetTipoRetorno(simbolo.GetType());  .) 
parent_ab [Parametros <simbolo>] parent_ce llave_ab Cuerpo (. tabla.CerrarAmbito(); .)
 llave_ce.




//***********************************************************//
/******************Llamadas*****************************/
LlamMet = ident punto ident { parent_ab parent_ce | parent_ab {Argumentos} parent_ce}
.

/******************INSTRUCCIONES****************************/
Instruccion
(. int type; .)
=
	InstReturn< out type > | InstCout | InstCin | InstExpresion | InstIfElse
.

InstExpresion
=	(. int type=undef; .)
		ident (. if (tabla.EstaRecur(t.val) == false)
			     	SemErr(t.val + " no ha sido declarado.");
			  .)
			[punto ident] ((parent_ab Argumentos parent_ce puntoComa)
				| ((op_asig | op_asig_mas | op_asig_menos |
					op_asig_producto | op_asig_division | op_asig_modulo) 
													Expresion<out type> puntoComa))
.

InstReturn <out int tipoDev>
(.	tipoDev = undef;
	int type; .)
=
(rreturn [Expresion<out type> (. tipoDev= type; .) ] puntoComa)
.

/****************************************************/

InstIfElse	
(. int type, type1;
	Simbolo sim = new Simbolo(t.val, 0, 0);
	Simbolo simbolo = new Simbolo(t.val, 0, 0);	// borrarcuando corrigas
.) 
=
		iff Expresion<out type> (.if (type != bool) {SemErr("La condicion de un if debe ser logica");}
								 .) 
	((llave_ab (. tabla.NuevoAmbito(); .) Cuerpo (. tabla.CerrarAmbito(); .) llave_ce) 
	//En caso de que no se habrán llaves no se abrirá un ámbito nuevo (no tiene ningún sentido)
	| Instruccion) 
		 [Else]
.

Else	(. int type;
	Simbolo sim = new Simbolo(t.val, 0, 0);	// borrarcuando corrigas
.) 
=
	elsse ((llave_ab (. tabla.NuevoAmbito(); .) Cuerpo (. tabla.CerrarAmbito(); .) llave_ce) 
			| Instruccion) .

/***************************************************/


/******************PRINT***********************/


InstCout
(. int type=undef; .)
=
	cout {menor_menor Arg_io<out type>} puntoComa (.if (type==undef) {
														SemErr("InstCout: Error tipos.");
													}.)
.

InstCin
(. int type; .)
=
	cin mayor_mayor Arg_io <out type> puntoComa
.

Arg_io<out int tipoDev>
(. tipoDev=undef;
   Simbolo sim = new Simbolo("Temp",0,0);
   int posicion; .)
=	ident (. if (!(tabla.EstaRecur(t.val)))
			 	SemErr(t.val + " no esta definido");
			 else if (sim.GetKind() == clase)
			 	SemErr(t.val + " es una clase");
			 else
			 	{
			 	sim = null;
			 	sim = tabla.GetSimboloRecur(t.val);
			 	tipoDev = sim.GetType();
			 	} .) 
		[DarPosVector <out posicion, sim>]
		| cadenaCar (. tipoDev = cadena; .)
		| Exp<out tipoDev, sim> (. tipoDev = entera; .)
.

DarPosVector <out int posicion, Simbolo sim> (. Simbolo simbolo_nuevo = new Simbolo("temp", 0, 0);
												int tipoDev; .)
= corchete_ab (. if (!(sim.Es_Vector()))
	 	SemErr(sim.GetNombre() + " definido en la linea " + sim.GetLine() + " columna " + sim.GetColumn() + " no es un vector");.)
 Exp<out tipoDev, simbolo_nuevo> corchete_ce (. if (tipoDev != entera)
 														  	SemErr("La posicion del vector debe ser una expresion de tipo entero");
 														  posicion = ((Number) simbolo_nuevo.GetValor()).intValue(); .)
.

/******************EXPRESIONES*****************************/
/*
Expresion<out int type> 
= (. type=undef; .)
(	enteros (.	type=entera;	.)
	| cadenaCar (.	type=cadena;	.)
	| true	(.	type=bool;	.)
	| false	(.	type=bool;	.)
).
*/
Expresion <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
 = Expresion2 <out type> Expresion1	<out type1>	(.	if (type==type1) {
 														tipoDev=type;
 													} else if (type1==undef) {
 														tipoDev=type;
 													} else {
 														SemErr("Error en Expresion");
 													}
												.)
.

Expresion1 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1, type2; 
.)
= ["?" Expresion<out type>":" Expresion <out type1> Expresion1 <out type2>]
.

Expresion2 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= Expresion3 <out type> Expresion21 <out type1> (.  if (type1==undef) {	// no hay segunda parte expr
														tipoDev=type;
													} else if (type1==entera) {	// Expresion con op_relacional
														if (type==type1) {
															tipoDev=entera;		// op_relacional ok!
														} else {
															SemErr("OpRelacional: Error argumentos.");
														}
													} else if (type1==bool) {	// Expresion con op_logico
														if (type==type1) {
															tipoDev=bool;	// op_logico ok!
														} else {
															SemErr("OpLogica: Error argumentos");
														}
													} else {
														SemErr("Operacion Expr2 problems"+type+" "+type1);
													}
												.)
.

Expresion21 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= [Operador_Logico Expresion3 <out type> Expresion21 <out type1> (.	if (type==bool) {
																		if (type1==undef) {	// todo ok!
																			tipoDev=type;
																		} else if (type1==bool) {	//2º ok!
																			tipoDev=type;
																		} else {				// 2º arg problem
																			SemErr("OpLogica: Error argumentos.");
																		}
																	} else {	// error en 1º arg
																		tipoDev=type;	// lo envio para q salte el error
																		SemErr("OpLogica: Error argumentos.");
																	}
																.)]
| [Operador_Relacional Expresion3 <out type> Expresion21 <out type1> (.	if (type==entera) {
																			if (type1==undef) {	// todo ok!
																				tipoDev=type;
																			} else if (type1==entera) {	//2º ok!
																				tipoDev=type;
																			} else {				// 2º arg problem
																				SemErr("OpRelacional: Error argumentos");
																			}
																		} else {	// error en 1º arg
																			tipoDev=type;	// lo envio para q salte el error
												 
												 							SemErr("OpRelacional: Error argumentos");
																		}
																.)
												]
.

/***********PRUEBAS_PRECEDENCIA_OP*******************/
Exp <out int tipoDev, Simbolo sim>
(.	tipoDev=undef;				// Si devuelvo este tipo es q algo fue mal!
	int valor=0, suma;
	int numErr=errors.count;	// Numero de errores actuales
.)
= [ ExpAritmetica<out suma>		(. if (numErr == errors.count) {	// todo fue ok!
										System.out.println("vas a sumar a "+valor+" el valor de"+suma);
										valor=suma+valor; 
								} .)
	]
	(. if (numErr == errors.count) {
			sim.SetValor(valor);
			tipoDev=entera;
		} .)
.

ExpAritmetica <out int suma>
(.	int numErr=errors.count;	// Numero de errores actuales
	int valor=0, valor1=0, valor2=0;		// inicializo
	suma=0;
	System.out.println("Estas en ExpArirmetica!");
.)
=	ExpProducto<out valor> 	(. if (numErr == errors.count) {	// todo fue ok!
									System.out.println("Una parte vale"+valor);
									suma= valor;
								} .)
								[{ op_mas ExpProducto<out valor1>
									(. if (numErr == errors.count) {	// todo fue ok! 	
										System.out.println("sumando! a "+suma+"el nuevo "+valor1);
									//	sim.SetValor(((Number) sim.GetValor()).intValue() + valor1);
										suma= suma+valor1; 
										} .)
								| (.System.out.println("antes de restar!");.)
										op_menos ExpProducto<out valor2>
									(. 	if (numErr == errors.count) {	// todo fue ok!
										System.out.println("restando!");
										//sim.SetValor(((Number) sim.GetValor()).intValue() - valor2);
										suma= suma-valor2; 
										} .)
								}]
(. System.out.println("Simbolo sale con valor:"+suma); .)
.

ExpProducto <out int total>
(.	int valor=0, valor1=0, valor2=1;
	total=0;
	System.out.println("Estas en expProducto"+la.val);
.)
= ExpCambioSigno<out valor> (.	total=valor; .)
                [{ op_producto ExpCambioSigno<out valor1> 
                				(. System.out.println("multiplicaste!");
                					total=total * valor1; .)
                	| op_division ExpCambioSigno<out valor2>
                				(. System.out.println("dividiste!");
                					total=total / valor2; .)
				}]
    			(. System.out.println("Valor de una parte"+total); .)
.
 
ExpCambioSigno <out int valor>
(.	int valor1=0;	// inicializo
	int sum=0;
	valor=0;		// Inicialiazo
	System.out.println("Entraste en camb Signo");
.)
=  
op_menos
	ExpCambioSigno<out valor1>							(. valor = -valor1; .)
	| parent_ab ExpAritmetica<out int suma> parent_ce 	(. valor=suma;		.)
	| ident	(. if (tabla.EstaEnActual(t.val)) {	// busco si esta el simbolo
					Simbolo sim = tabla.GetSimboloRecur(t.val);
					if (sim.GetKind()==var) {	// Es var. entera
						valor = ((Number) sim.GetValor()).intValue();	// asigno el val del ident
					} else if (((sim.GetKind()==funcion) || (sim.GetKind()==metodo))	// funcion o metodo 
									&& (sim.GetTipoRetorno()==entera)) {	// Devuelve un entero
						System.out.println("NO HAY ASIGNACION TODAVIA");
						System.out.println("Identificador de una funcion o metodo que devuelve un entero, ok!");
					} else {	// sino valor entero->error"
						SemErr("Identificador no devuelve Entero!");
					}
				} else {
					SemErr("Error: Identificador no existe");
				}
			.)
	| enteros (. valor = Integer.parseInt(t.val); .)
	| ExpOperadores<out valor> (. 	if (valor==entera)	{
										System.out.println("es entero");
									} else {
										SemErr("No es entero!es un:"+t.val);
									}
								.)
.

ExpOperadores <out int tipoDev> 
(.  tipoDev=undef;
	int type1, type;
	System.out.println("estas en expoperadores");
.)
= 
| cadenaCar		(. tipoDev=cadena;	.) 
| "true"		(. tipoDev=bool;	.)
| "false"		(. tipoDev=bool;	.)
.

/****************************************************/
Expresion3 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= Expresion4 <out type> Expresion31 <out type1> (. 	if (type1==undef) {
														tipoDev=type;
													} else if ((type==type1) && (type1==entera)) {
														tipoDev=type;
													} else {
														SemErr("Operacion Arit sobre tipos no enteros");
													}
												  .)
.

Expresion31 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1;
.)
= [Operador_Aritmetico Expresion4 <out type> Expresion31 <out type1> (. if (type1==undef) {	// No hay 2º parte
																			if (type==entera) {	// todo ok!
																				tipoDev=type;
																			} else {			// NO es un tipo ENTERO
																				SemErr("Operacion Arit con arg no entero");
																			}
																		} else {	// hay otro expresion
																			if ((type==type1) && (type==entera)) {	// las dos son
																				tipoDev=type;
																			} else {
																				SemErr("Operacion Arit sobre tipos no enteros");
																			}
																		}
																	  .)
																	]
.

Expresion4 <out int tipoDev>
(.	tipoDev=undef;
	int type, type1, type2;
.)
= op_negacion Expresion4 <out type> (.	if (type==bool) {
											tipoDev=type;
										} else {
											SemErr("OpNegLogico: Error argumento.");
										}
									.)
| op_menos Expresion4<out type1>	(.	if (type1==entera) {
											tipoDev=type1;
										} else {
											SemErr("OpNegAritmetico: Error argumento.");
										}
									.)
| Expresion5 <out type2> (. tipoDev=type2; .)
.

/* Expresion 5 recoge todos los siguientes supuestos:

			Constructor
			ident
			ident.ident
			ident (Argumentos)
			enteros
			Todas aquellas Expresiones que contienen los siguientes operadores
					
							Aritméticos (+)
							Relación    (<)
							Lógicos   	(!)  
							Asignacion 	(=)
							Condicional
							Acceso a miembros de una clase (.)
							Acceso a un vector ([])
*/


Expresion5 <out int tipoDev> 
(.  tipoDev=undef;
	int type1, type;
.)
= 
"(" Expresion <out type1> ")"	(. tipoDev=type1; .)
| "new" ident "("Argumentos")"       /*Constructor*/
| ident ["."ident ["("Argumentos")"] 
	| "("Argumentos")"
	| "["Expresion <out type> "]" (. tipoDev=type;.)]
| enteros		(. tipoDev=entera;	.)
| cadenaCar		(. tipoDev=cadena;	.) 
| "true"		(. tipoDev=bool;	.)
| "false"		(. tipoDev=bool;	.)
.

Expresion_Entera = (enteros | ident) [Operador_Aritmetico Expresion_Entera]
					| parent_ab Expresion_Entera parent_ce [Operador_Aritmetico Expresion_Entera]
.

/**********************************************************/

Argumentos
=	(. int type=undef; .)
[Expresion<out type> {"," Argumentos}]
.


Operador_Aritmetico = op_mas | op_menos | op_producto | op_division
.

Operador_Logico = op_or | op_and | op_negacion
.
				
Operador_Relacional = op_menor | op_mayor |   op_menor_igual
				| op_mayor_igual | op_igual | op_distinto
.

END CEMASMAS1.
