/*
Autores: Víctor Gómez Aragoneses
		 Luis Ildefonso Gómez Solana
*/
import java.util.Vector;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.Queue;
import java.io.*;
import java.util.*;

// Set the name of your grammar here (and at the end of this grammar):
COMPILER CEMASMAS1
//	import java.util.*;
// Add auxiliary methods and declaration here.
	// Declaracion de constantes para tipos
	final int undef=0, entera=1, bool=2, cadena=3, vacio=4, identificador=5, vector=6;
	// Declaración de constantes de tipo de scopes
	final int var=0, funcion=1, clase=2, metodo=3, parametro=4;
	//Declaración de visibilidad
	final int privado=0, publico=1;

	// Tabla de simbolos global
	public Tablas tabla;
	// Tupla devuelta por las expresiones (tipo, valor)
	
	// Este simbolo servira para indicar la clase del objeto encontrado por ValorFinalExp
	// En realidad es una solucion un poco chapuza, pero es necesario tenerlo aqui
	public Simbolo simboloClaseObjeto = null;
	
	//Utilizaremos este simbolo para ir anadiendo los valores temporales a la tabla de simbolos
	public Simbolo simboloNuevoTemporal = null;
	
	// Esta variable indicará si se ha producido un return en una funcion/metodo que devuelva
	// algo distinto de void
	public boolean hayreturn = false;
	
	//Otra chapucilla
	int indice_vector = -1;
	
	//Otra chapuza mas
	Simbolo simboloObjetoGlob = null;

	// Clase tercetos.
	Tercetos tercetos = new Tercetos();
	String terceto_actual;
	LinkedList<tupla_Tercetos> colaTercetos = new LinkedList<tupla_Tercetos> ();
    LinkedList<tupla_Tercetos> colaMain = new LinkedList<tupla_Tercetos> ();
	
	GenFinal codigo_final;
	// Fichero de salida para el codigo Ensamblador
	String fichero = new String("/tmp/CodigoObjeto");
// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit.
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.
  letter2		= 'A' .. 'Z' + 'a' .. 'z' + '_'.

  c1 			= ANY - "\"".
  c3 			= 'A' .. 'Z' + 'a' .. 'z' + '_' + digit.
  c4			= ANY - cr.
  c5			= ANY - "*".
  c6 			= ANY - "/".

TOKENS
  ident = letter { letter2 | digit }.


  enteros = ( zero | nonZeroDigit { digit }).
  
  cadenaCar = "\"" { c1 } "\"".


  bool = "boolean".
  boool = "bool".
  charr    = "char".
  classs   = "class".
  ffalse   = "false".
  intt     = "int".
  new     = "new".
  short   = "short".
  static  = "static".
  ttrue    = "true".
  voidd    = "void".
  publicc = "public".
  privatte = "private".
  dospuntos_dos = "::".
  rreturn = "return".
  cout = "cout".
  cin = "cin".
  menor_menor = "<<".
  mayor_mayor = ">>".
  iff = "if".
  elsse = "else".
  main = "main".
  
  
  dosPuntos   = ":".
  comma   = ",".
  punto     = ".".
  llave_ab  = "{".
  corchete_ab  = "[".
  parent_ab    = "(".
  op_menos   = "-".
  op_menosmenos   = "--".  

  op_mas    = "+".
  op_masmas = "++".
  llave_ce  = "}".
  corchete_ce  = "]".
  parent_ce    = ")".
  op_producto	= "*".
  op_division		= "/".

  op_asig           = "=".
  puntoComa			= ";".
  doblesComillas	= '"'.
  interrogacion		= "?".
  barra_vert = "|".

  op_negacion    = "!".
  op_menor	   	 = "<".
  op_mayor		 = ">".
  op_menor_igual = "<=" .
  op_mayor_igual = ">=" .
  op_igual			= "==".
  op_distinto = "!=".
  op_and = "&&".
  op_or = "||".
  
  op_asig_mas = "+=".
  op_asig_menos = "-=".
  op_asig_producto = "*=".
  op_asig_division = "/=".
  op_asig_modulo = "%=".
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab



//PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .
CEMASMAS1 (.	tabla = new Tablas();	.)  //Se crea el ámbito global
= CEMASMAS (. int desplazamiento; 
			  desplazamiento = tabla.GetAmbitoGlobal().ActualizarDesplazamiento();
			  System.out.println("El desplazamiento del ambito global es " + desplazamiento);
			  tercetos = new Tercetos();
			  try {
			  	if (errors.count==0) {	// todo ok! 
			  		codigo_final = new GenFinal(colaTercetos, tabla, fichero);
			  	}
			  } catch( Exception e ) {	// Codigo Final genera excepcion
			  	System.err.println("Generación de Código Final desbocado.");
			  }
			.)
.

// Punto de entrada del codigo fuente, acabará SIEMPRE en un MAIN
CEMASMAS
(.	int type=undef; 
	int type1;
	Simbolo simbolo_dev = null;
	String nombre = null;	// podre ser nombre de Objeto
.)
=
	DecClase CEMASMAS
			 | ((Ttipo<out type>	// Existe este tipo ident¿?
			 						(.	nombre = new String(t.val);
			 							if (type==identificador) {
											Simbolo simbolo = new Simbolo(t.val, type, 0);
											simbolo.SetLine(t.line);
											simbolo.SetColumn(t.col);
											if ((tabla.EstaRecur(simbolo.GetNombre()))) {	// este ident ya existia!, ok!
												simbolo_dev = tabla.GetSimboloRecur(simbolo.GetNombre());
													if (simbolo_dev.GetKind() != clase)
														SemErr(simbolo_dev.GetNombre() + " Error declaracion.");
											} else {
												SemErr(t.val + " no declarado anteriormente.");
											}
										}
			 						.)
			 			| voidd (. type = vacio;.)
			 				/*| ident	(.	// En caso de declarar un Objeto de una clase
											Simbolo simbolo = new Simbolo(t.val, type, 0);
											simbolo.SetLine(t.line);
											System.out.println("Declarando objeto de clase");
											simbolo.SetColumn(t.col);
											if (tabla.EstaEnActual(simbolo.GetNombre())) {
												Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
												SemErr(simbolonuevo.GetNombre() + " ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
											} else {
											   tabla.InsertarEnActual(simbolo);
											}
	 									.)	*/
	 							) //Parentedid de Ttipo|voidd|ident
			 			(Main <type, nombre>
			 				| ident	
			 						(. Simbolo simbolo = new Simbolo(t.val, type, var);
			 						   simbolo.SetLine(t.line);
			 						   simbolo.SetColumn(t.col);
			 						   if ((simbolo_dev != null) && (simbolo_dev.GetKind() == clase))
			 						   			simbolo.SetClase(simbolo_dev);

			 						   Simbolo sim = tabla.GetSimboloRecur(t.val);
			 						   // Metodo de una clase: Persona::daAnio
			 						   if (la.val.equals((String) "::")) { // casting, si el siguiente es metodo, caso especial
			 						   		if (tabla.EstaEnActual(simbolo.GetNombre())		// Existe
			 						   					&& (sim!=null) && (sim.GetKind()==clase)) {	// y es de tipo clase
			 						   			System.out.println("Metodo de una clase existente!(Clase:"+simbolo.GetNombre()+"), todo ok!");
			 						   		} else {
			 						   			SemErr("No existe la clase: "+t.val);
			 						   		}
			 						   } else if (tabla.EstaEnActual(simbolo.GetNombre())) {
			 						   		Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
			 						   		SemErr(simbolonuevo.GetNombre() + " ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
										} else {
											//SemErr("No existe ningún objeto "+simbolo.GetNombre()+" creado.");
											tabla.InsertarEnActual(simbolo); // Estaba puesto antes...
										}
			 						.)
			 					  	(Subprograma <simbolo>
			 					  		|  Vector<simbolo> 
			 					  				puntoComa 
			 					  			| DecVar<simbolo>
						 				| 	(.	String Clase= (String) t.val; .)
						 						DecMetodo<Clase, type, nombre>	// se envia nombre de clase y tipo retorno del metodo
									)
								CEMASMAS))
.

Ttipo<out int type>	// Devolvemo un entero con el tipo
= 				(.	type = undef; //inicializamos
				.)
(	intt		(. type = entera;	.)	
	| bool		(. type = bool; 	.)	// Entendemos que estos dos
	| boool		(. type = bool; 	.)	// son el mismo tipo		
	| charr [op_producto] 	(. type = cadena; .)
	| ident		(. type = identificador; .)	// tipo identificador	
).

//******************************************************************//


DecClase	(. int visible=privado; .) // Visibilidad del contenido, por defecto PRIVADO
= (. Simbolo simbolo = new Simbolo ("undef", 0, clase); System.out.println("DecClase!");.)
	[publicc (. simbolo.SetVisibilidad(1); .) 
		| privatte (. simbolo.SetVisibilidad(0); .)]
 	classs ident (. simbolo.SetNombre(t.val);	// Modifico el nombre del Simbolo
					simbolo.SetLine(t.line);
					simbolo.SetColumn(t.col);
					if ((tabla.EstaEnActual(t.val)) &&
							(tabla.GetSimboloRecur(t.val) != null) &&
								(tabla.GetSimboloRecur(t.val).GetKind()==clase) ) {
						SemErr("Clase "+ t.val +" ya definida en línea "+tabla.GetSimboloRecur(t.val).GetLine()+
									" y columna:"+ tabla.GetSimboloRecur(t.val).GetColumn());
						// Consumimo todo hasta el final de la clase
						while (!((t.val.equals((String) "}")) && (la.val.equals((String) ";")))) {	// fin de clase
							.) ANY (.	// Consumo todo hasta final clase
						}
					} else {	// Nueva clase!
						tabla.InsertarEnActual(simbolo);
						tabla.NuevoAmbito(simbolo);		// Nuevo ambito para meter metodos
				.)
							llave_ab	// y variables de la clase.
								Cuerpo_Clase<visible, simbolo>
									[(publicc	(. visible=publico; .) 
										dosPuntos Cuerpo_Clase<visible, simbolo> 
											[privatte dosPuntos (. visible=publico; .) 
												Cuerpo_Clase<visible, simbolo>])
									|(privatte	(. visible=privado; .) 
										dosPuntos Cuerpo_Clase<visible, simbolo> 
											[publicc dosPuntos 	(. visible=publico; .) 
												Cuerpo_Clase<visible, simbolo>])
									]
							llave_ce
				(.		
						tabla.CerrarAmbito();
					}	// fin else, para el ambito de nua clase OK! 
				.)
	puntoComa
.

Cuerpo_Clase <int visible, Simbolo simClase>
	(.	int type;
		Simbolo ObjetoDevuelto=null;	// inicializado
	.)	// Recuerda! estas en un ambito clase 
= [{(Ttipo<out type> 	(.	Simbolo sim = new Simbolo("elem_clase", 0, 0);	// Creacion del simbolo
							sim.SetClase(simClase);	// clase a la q pertenece
						    if (type==identificador) {
						    	if ((tabla.GetSimboloRecur(t.val) != null) &&
									(tabla.GetSimboloRecur(t.val).GetKind()==clase)) {
								//Guardamos la dirección para engancharlo luego
									ObjetoDevuelto=tabla.GetSimboloRecur(t.val);
								} else {
									SemErr("No existe ningun objeto con dicho nombre.");
								}
							}
							tabla.InsertarEnActual(sim);
						.)
						ident (.sim.SetNombre(t.val);
								sim.SetVisibilidad(visible);
								sim.SetLine(t.line);
	 						    sim.SetColumn(t.col);
	 						    //System.out.println(t.val+" Simbolo q estas mirando, y su tipo:"+type);
							.)
						( 	(. /* Caso en que es una Declaracion de variable */
								sim.SetKind(var);	// Es variable
								sim.SetType(type);	// Su tipo
								if (type==identificador) {
									sim.SetClaseDevuelta(ObjetoDevuelto);
								}
							.) 
								DecVar<sim> 
							| (./* Caso Declaracion Cabecera de un metodo */
								sim.SetKind(metodo);
								sim.SetTipoRetorno(type);
								sim.SetClase(simClase);		// a q clase pertenece le metodo
								sim.SetAmbitoAsociado(tabla.GetAmbitoActual());	// ambito de accion
								//System.out.println("El Metodo pertenece a la clase:"+sim.GetClase().GetNombre());
								if (type==identificador) {
									sim.SetClaseDevuelta(ObjetoDevuelto);	//devuelve un tipo objeto
									//System.out.println("Clase devuelta:"+ObjetoDevuelto.GetNombre());
								}
								.)
								DecCabMet<sim>
						)
		)
							  | voidd ident (.	Simbolo simbol = new Simbolo(t.val, 0, metodo);
											  		simbol.SetKind(metodo);
											  		simbol.SetTipoRetorno(vacio);
													simbol.SetClase(simClase);		// a q clase pertenece le metodo
													simbol.SetAmbitoAsociado(tabla.GetAmbitoActual());	// ambito de accion
							  				.) 
							  		DecCabMet<simbol>	// tiene q ser un metodo
	}]
.


DecCabMet<Simbolo simbolo>
	(. int type; .) 
	// ERROR: nuevo ambito para esto
= parent_ab Param_Cab<simbolo> parent_ce
  puntoComa
.

Param_Cab <Simbolo simbolo>
= (. int type; .)
	[Ttipo<out type> (.	Simbolo sim = new Simbolo("Arg_Metodo",0,parametro); .)
						[Vector<sim>	(. System.out.println("Funcionalidad por hacer");.)]
			(.	sim.SetType(type);
				simbolo.AnadirParametro(sim);
			.)	
		[ comma Param_Cab<simbolo>]
	| voidd ]
.

DecMetodo<String Clase, int tipoRetorno, String Nombre>	// Nombre= caso de tipoReturn=identificador, es decir, dev un Objeto 
= (. Simbolo simDecMetodo = new Simbolo("simDecMetodo", 0, metodo);		// Anado metodo al ambito actual
	 boolean hay_param=false;
	 //System.out.println("Estas en declaracion Metodo");
.)
	dospuntos_dos ident	(.	//System.out.println("Comprobando si el metodo "+t.val+" pertenece a la clase "+Clase);
							if ((tabla.GetSimboloRecur(Clase) != null) &&	// clase existe?¿
									(tabla.GetSimboloRecur(Clase).GetKind()==clase)) {
									//clase y metodo existen!
									if (tabla.GetSimboloRecur(Clase).GetAmbitoAsociado().Esta(t.val)) {	// metodo asoc a clase¿?
										// Cojo el simbolo del metodo que se declaro dentro de la clase
										Simbolo simMetodo=tabla.GetSimboloRecur(Clase).GetAmbitoAsociado().GetSimbolo(t.val);
										// Comprobacion tipoRetoron y argumentos son iguales
										if (simMetodo.GetTipoRetorno()==tipoRetorno) {
										
											/*Comprobacion de tipo devuelvo DecMetodo correcto y del mismo Objeto (si es ident)*/
											if (tipoRetorno==identificador) {
												if ((tabla.GetSimboloRecur(Nombre)!=null) &&	// Existe
														(tabla.GetSimboloRecur(Nombre).GetKind()==clase) &&	// es clase¿?
															(!(simMetodo.GetClaseDevuelta().GetNombre().equalsIgnoreCase(Nombre))) ) {
													SemErr("Clases devueltas difieren");
												}
											}
											tabla.AbrirAmbito(tabla.GetSimboloRecur(Clase).GetAmbitoAsociado());											
											// Nuevo ambito para la dec del metodo
											tabla.NuevoAmbito(simMetodo);
											//simMetodo.SetAmbitoAsociado(tabla.GetAmbitoActual());
											.)
											parent_ab
														[Parametros<simMetodo> (. hay_param=true; .) ]
											parent_ce
											(.
												if ((!(hay_param)) && 
														(simMetodo.GetNParametros()!=0)) {	// No hemos entrado en parametros
													SemErr("Error tipos declaracion Metodo.");
												}
											.)
											llave_ab (.simMetodo.SetEtiqueta(tercetos.darEtiqueta());.)
												Cuerpo<simMetodo> (.if ((simMetodo.GetTipoRetorno() != vacio) && !hayreturn)
																		SemErr("El metodo tiene que devolver el tipo especificado en la declaracion (no hay sentencia return)");
																	else
																		hayreturn = false;.)
											llave_ce
											(.
											tabla.CerrarAmbito();	// cierro ambito del metodo
											tabla.CerrarAmbito();	// Cerramos el ambito de la clase
																	// y volveremos, seguramente, al global
										} else {
											SemErr("Declaración metodo devuelve un tipo diferente a la declaración en la Clase: "+Clase+", en linea-col:"+simMetodo.GetColumn()+"-"+simMetodo.GetColumn());
										}
									} else {
										SemErr("Existe la clase: "+Clase+", pero no tiene ningun metodo asociado: "+t.val);
									}
							} else {
								SemErr("No existe dicha clase: "+Clase);
								.)
								llave_ab
									Cuerpo<simDecMetodo>	// simDecMetodo-> no vale para nada!
								llave_ce
								(.
							}
						.)
.



//******************************************************************//
Main<int type, String nombre> = (. Simbolo simbolo_funcion = new Simbolo("main",type,funcion);
								   Simbolo simbolo_clase = null;
								   hayreturn = false;
								   simbolo_funcion.SetEtiqueta(tercetos.darEtiqueta());
								   tabla.InsertarEnActual(simbolo_funcion);								   
								 .)
	   main   (.tabla.NuevoAmbito(simbolo_funcion);
			  simbolo_funcion.SetKind (funcion);
			  simbolo_funcion.SetTipoRetorno(simbolo_funcion.GetType());
			  //Añadimos el terceto a la cola de tercetos!
			  terceto_actual=tercetos.EtiquetaSubprograma(simbolo_funcion.GetEtiqueta());
			  tupla_Tercetos tupla= new tupla_Tercetos(tabla.GetAmbitoActual(),terceto_actual);
			  colaTercetos.add(tupla);
			  
			  if (simbolo_funcion.GetTipoRetorno() == identificador)
					{
					if (!(tabla.EstaRecur(nombre)))
						SemErr("No se ha encontrado ninguna clase con nombre " + nombre);
					else
						simbolo_clase = tabla.GetSimboloRecur(nombre);
						if (simbolo_clase.GetKind() != clase)
							SemErr(identificador + " no es una clase");
						else
							simbolo_funcion.SetClaseDevuelta(simbolo_clase);
					} .)   
	   parent_ab [voidd] parent_ce llave_ab Cuerpo<simbolo_funcion>
	   															   (.
	   															    if ((simbolo_funcion.GetTipoRetorno() != vacio) && !hayreturn)
																   		{
																   		System.out.println(simbolo_funcion.GetTipoRetorno());
																   		SemErr("La funcion tiene que devolver algo (No se ha encontrado instruccion Return)");
																   		}
															   		else
															   			hayreturn = false; 
	   															   .)
	    llave_ce (.tabla.CerrarAmbito();.)
.

Cuerpo <Simbolo simbolo_funcion> 	(. int type = undef; .) 
= (. Simbolo simbolo_anterior = null;
	 boolean estaba_declarado = false;.)
	{Instruccion <simbolo_funcion>
		| ((Ttipo<out type> | voidd) (. if (type == identificador)
											 {
											 if (!(tabla.EstaRecur(t.val)))
											 	{
											 	SemErr(t.val + " no ha sido declarado previamente");
											 	}
											 else
											 	{
											 	simbolo_anterior = tabla.GetSimboloRecur(t.val);
											 	estaba_declarado = true;
											 	}
											 }
										else if (la.val.contentEquals("["))
												SemErr("No existe el tipo especificado");
									 .)
									 [(.Simbolo simbolo_lo_que_tiene_el_vector = new Simbolo("Estesimbolonovale", entera, var);.)
									 DarPosVector<simbolo_anterior, simbolo_lo_que_tiene_el_vector>]
											 	)
									 
									 
									 
									 (Llamada<simbolo_anterior> 
									 | 
									 InstExpresion <simbolo_anterior> 									 
									 |
										  (ident (.
										  if (estaba_declarado)
										  	{
										  	if (simbolo_anterior.GetKind() != clase) 
										 		{
										 		SemErr("Se esperaba un tipo o un identificador declarado como una clase: '" + simbolo_anterior.GetNombre() + "' declarado en la linea " + simbolo_anterior.GetLine() + " columna " + simbolo_anterior.GetColumn() + " no fue declarado como una clase");
										  		}
										  	} 
										  Simbolo simbolo = new Simbolo(t.val, type, 0);
			 						 	  simbolo.SetLine(t.line);
			 						   	  simbolo.SetColumn(t.col);
			 						   	  simbolo.SetClase(simbolo_anterior);
			 						   
			 						   	  if (tabla.EstaEnActual(simbolo.GetNombre()))
			 						   			{
			 						   			Simbolo simbolonuevo = tabla.GetSimboloRecur(t.val);
			 						   			SemErr("'" + simbolonuevo.GetNombre() + "' ya estaba declarado en la linea " + simbolonuevo.GetLine() + " columna " + simbolonuevo.GetColumn());
			 						   			}
			 						   	  else
			 						   	  		{
			 							   		tabla.InsertarEnActual(simbolo);
			 							   		}	
			 							   	.) 
			(Subprograma <simbolo>
		 | (Vector<simbolo> puntoComa | DecVar<simbolo> ))))}
.



DecVar <Simbolo simbolo_anterior>
= (.simboloClaseObjeto = null;
	int type = undef;
	Simbolo simbolo_temp = null;.)
[op_asig VExpresion<out type, simbolo_temp>	(. if (type != simbolo_anterior.GetType())
								 	SemErr("Error de tipos en la inicializacion de la variable");
								 	else if (type == identificador)
								 		{
								 		if (simbolo_anterior.GetClase() == null)
								 			SemErr("Error de tipos en la inicializacion de la variable. Error en la clase.");
								 		else if (simbolo_anterior.GetClase() != simboloClaseObjeto)
								 			SemErr("Error de tipos en la inicializacion de la variable. Clases distintas.");
								 		}
								 	else
								 		simbolo_anterior.SetValor(null); //Así la variable constará como inicializada
								 		simboloClaseObjeto = null;
								.)
							] puntoComa
	(.	if (simbolo_temp == null) {	// caso: int Var;
			simbolo_anterior.SetEtiqueta(tercetos.darEtiqueta());
		} else {	// caso: int Var=Expresion;
		}
	.)
.


Parametros <Simbolo simbolo_nombre_funcion>
(. int type, contador=0;
   String nombre_clase = null;.) 
= 	Ttipo<out type> (. nombre_clase = new String(t.val);.)
					ident (. Simbolo simbolo_parametro = new Simbolo(t.val, type, parametro);
							simbolo_parametro.SetLine(t.line);
							simbolo_parametro.SetColumn(t.col);
							if (type == identificador)
								{
								if (!(tabla.EstaRecur(nombre_clase)))
									SemErr(t.val + " no estaba declarado previamente");
								else
									{
									Simbolo simbolo_clase = tabla.GetSimboloRecur(nombre_clase);
									if (simbolo_clase.GetKind() != clase)
										SemErr(t.val + " no es una clase");
									else
										simbolo_parametro.SetClase(simbolo_clase);
									}
								}
							if (simbolo_nombre_funcion.GetKind() != metodo) {						
									simbolo_nombre_funcion.AnadirParametro(simbolo_parametro);
									tabla.InsertarEnActual(simbolo_parametro);		
							} else { // Caso decMetodo
								System.out.println("Estas en caso decMetodo PARAMETROS.");
								if (simbolo_nombre_funcion.GetNParametros() == 0) {
									SemErr("Error numero argumentos en declaracion Metodo.");
								} else {
									if (simbolo_nombre_funcion.GetParametros(contador).GetType()!=type) { 
										SemErr("Error tipos declaracion Metodo.");
									} else {	// coincide en tipos
										simbolo_nombre_funcion.GetParametros(contador).SetNombre(t.val);
										//String temp_nueva = new String(t.val);
										//simbolo_nombre_funcion.GetParametros(0).SetNombre(temp_nueva);
										tabla.InsertarEnActual(simbolo_nombre_funcion.GetParametros(contador));	// inserto en ambito Metodo el simb
										contador++;
									}
								}
							}
 						.) 
				[Vector <simbolo_parametro>]
				[{comma Ttipo<out type>ident (. simbolo_parametro = new Simbolo(t.val, type, parametro);
												simbolo_parametro.SetLine(t.line);
												simbolo_parametro.SetColumn(t.col);
												if (simbolo_nombre_funcion.GetKind() != metodo) {						
													if (tabla.EstaEnActual(simbolo_parametro.GetNombre())) {
														SemErr("Hay otro parametro con el mismo nombre");
													} else {
														simbolo_nombre_funcion.AnadirParametro(simbolo_parametro);
														tabla.InsertarEnActual(simbolo_parametro);		
													}
												} else { // Caso decMetodo
													System.out.println("Estas en caso decMetodo PARAMETROS.");
													if (simbolo_nombre_funcion.GetNParametros() == 0) {
														SemErr("Error numero argumentos en declaracion Metodo.");
													} else {
														if (simbolo_nombre_funcion.GetParametros(contador).GetType()!=type) { 
															SemErr("Error tipos declaracion Metodo.");
														} else {	// coincide en tipos
															simbolo_nombre_funcion.GetParametros(contador).SetNombre(t.val);
															//String temp_nueva = new String(t.val);
															//simbolo_nombre_funcion.GetParametros(0).SetNombre(temp_nueva);
															tabla.InsertarEnActual(simbolo_nombre_funcion.GetParametros(contador));	// inserto en ambito Metodo el simb
															contador++;
														}
													}
												}
											 .) 
					[Vector <simbolo_parametro>]
				}] 
				| voidd (.	System.out.println("Estas en caso decMetodo PARAMETROS.");
							if (simbolo_nombre_funcion.GetKind() == metodo) {
								if (simbolo_nombre_funcion.GetNParametros() != 0)
									SemErr("Error tipos declaracion Metodo.");
							}
						.)
.

Vector <Simbolo simbolo> =
corchete_ab enteros	(.	if (simbolo.GetType() != entera)
							SemErr("El contenido de un vector debe ser de tipo entero");
						try {										
							if (Integer.parseInt(t.val) == 0)
								SemErr("Error declarando la dimension del vector");
							
							simbolo.SetToVector(Integer.parseInt(t.val)); //Si no ha venido un entero se generara una excepcion
							}
						catch (NumberFormatException e)
							{
							System.out.println("Deberia haberse especificado la dimension del vector");
							}
					.)
 corchete_ce.


//*********************LLAMADA***********************************//

Llamada <Simbolo simbolo_objeto> //Cuando llegamos aquí, simbolo_objeto debería contener la información del identificador anterior
= (. TablaSimbolos ambito_clase = null; //Atención!! Llamada solo sirve para llamar a un método.
	 Simbolo simbolo_metodoargumento = null;
	 System.out.println("Entramos en Llamada");
	 simboloObjetoGlob = simbolo_objeto; .) 
punto ident (. if (simbolo_objeto != null)
				 	{
				 	Simbolo simbolo_clase =  simbolo_objeto.GetClase();
				 	if (simbolo_clase == null)
				 		SemErr("El identificador " + simbolo_objeto.GetNombre() + " no ha sido declarado perteneciente a ninguna clase.");
				 	else
				 		{
				 		ambito_clase = simbolo_clase.GetAmbitoAsociado();
				 		if (ambito_clase == null)
				 			SemErr("La clase " + simbolo_clase.GetNombre() + " no tiene ningun ambito asociado");
				 		else
				 			{
				 			if (!(ambito_clase.Esta(t.val)))
				 				SemErr("El identificador " + t.val + " no se ha encontrado declarado en la clase " + simbolo_clase.GetNombre());
				 			else
				 				{
				 				simbolo_metodoargumento = ambito_clase.GetSimbolo(t.val);
				 				if (simbolo_metodoargumento.GetVisibilidad() == privado)
				 					SemErr(simbolo_metodoargumento.GetNombre() + " no es publico.");
				 				}
				 			}
				 		} 
				 	}.) 

((parent_ab (.if (simbolo_metodoargumento != null)
					{
					if (simbolo_metodoargumento.GetKind() != metodo) //Si hay un paréntesis tiene que ser un método, y debe ser público.
						{
						SemErr("'" + simbolo_metodoargumento.GetNombre() + "' declarado en la linea " + simbolo_metodoargumento.GetLine() + " no fue declarado como un metodo");
						}
					else if (simbolo_metodoargumento.GetVisibilidad() == privado)
					 	SemErr(simbolo_metodoargumento.GetNombre() + " no es un metodo publico.");
			 		}
			 	.)
 VArgumentos<simbolo_metodoargumento, 0> parent_ce puntoComa)
 | InstExpresion<simbolo_metodoargumento> (.simboloObjetoGlob = null;.))
.

//**************************************************************//




//*************SUBPROGRAMA**********************************//




Subprograma <Simbolo simbolo_funcion> = (.  tabla.NuevoAmbito(simbolo_funcion);
											simbolo_funcion.SetKind (funcion);
											simbolo_funcion.SetTipoRetorno(simbolo_funcion.GetType()); //Cuando se ha creado el símbolo que nos pasan, en type se ha metido el tipo de retorno.
											simbolo_funcion.SetType(undef);
											simbolo_funcion.SetEtiqueta(tercetos.darEtiqueta());
											// Una vez generada la eti añado a la cola de tercetos
											
											if (simbolo_funcion.GetTipoRetorno() == identificador)
												{
												simbolo_funcion.SetClaseDevuelta(simbolo_funcion.GetClase()); //Cuando se ha creado el simbolo que nos pasan, en Clase se ha metido el símbolo de la clase que vamos a devolver.
												}  .) 
parent_ab [Parametros <simbolo_funcion>] parent_ce llave_ab Cuerpo<simbolo_funcion> 
															(. tabla.CerrarAmbito();
															   if ((simbolo_funcion.GetTipoRetorno() != vacio) && !hayreturn)
															   		{
															   		System.out.println(hayreturn);
															   		SemErr("La funcion tiene que devolver algo (No se ha encontrado instruccion Return)");
															   		}
															   else
															   		hayreturn = false; .)
 llave_ce.



/******************INSTRUCCIONES****************************/
Instruccion <Simbolo simbolo_funcion> //Se le pasa el simbolo de la funcion o metodo que este activa en ese momento.
(. int type = undef; .)
= (. System.out.println("Estamos en Instruccion");.)
	InstReturn< out type > (. if (simbolo_funcion.GetTipoRetorno() != type)
							  		SemErr("return devuelve un tipo distinto al declarado.");
							  else if (type == identificador)
							  		{
							  		if (simbolo_funcion.GetClaseDevuelta() != simboloClaseObjeto)
							  			{
							  			SemErr("return devuelve una clase distinta a la declarada.");
							  			}
							  		}
							  .)
	| InstCout | InstCin | InstIfElse<simbolo_funcion>
.

InstExpresion <Simbolo simbolo>
=	(. int type=undef;
	   System.out.println("Entramos en InstExpresion");
	   simboloClaseObjeto = null;
	   Simbolo simbolo_resultado = new Simbolo(tercetos.darTemporal(), undef, var);
	   int ind_vector = indice_vector; //Guardamos indice_vector por si el simbolo anterior era un vector y no queremos perder el indice
	   if (!(t.val.contentEquals("]")))
	   		{
	  	    if (((la.val.contentEquals("=")) || (la.val.contentEquals("+=")) || (la.val.contentEquals("-=")) || (la.val.contentEquals("*="))|| (la.val.contentEquals("/="))|| (la.val.contentEquals("%="))) && simbolo.Es_Vector())
	   			SemErr("Operacion no permitida: La parte izquierda de la asignacion es un vector");
			}
	   		 .)
				 (parent_ab VArgumentos <simbolo, 0> parent_ce puntoComa //Llamada a una función
				| 	//(. if .)
					(op_asig | op_asig_mas | op_asig_menos |
					op_asig_producto | op_asig_division | op_asig_modulo)
													VExpresion<out type, simbolo_resultado>
													(. try
															{
															if ((simbolo.GetType() != type) && (simbolo.GetType() != vector))
														   		SemErr("El tipo del identificador no coincide con el tipo de la expresion.Nombre");
														   	else if ((simbolo.GetType() == vector) && (type != entera))
														   		SemErr("El tipo del identificador no coincide con el tipo de la expresion.Nombre");
															else if (type == identificador)
																{
																if (simbolo.GetClase() != simboloClaseObjeto)
																	{
																	SemErr("La clase del identificador no coincide con la clase de la expresion");
																	}
																else
																	simboloClaseObjeto = null;
																}
															}
														catch (NullPointerException e)
															{
															}
														
														.) 
														(.
														if (simbolo.GetType() == vector)
															{
															String terceto = new String(tercetos.a_elemento_vector(simbolo.GetNombre(), ind_vector, simbolo_resultado.GetNombre()));
															tupla_Tercetos tupla_temp = new tupla_Tercetos(tabla.GetAmbitoActual(),terceto);
											 			    colaTercetos.add(tupla_temp);
			   												}
			   											else if (simboloObjetoGlob != null) //En este caso sera en el que estemos ante un atributo de un objeto
			   												{
															String terceto = new String(tercetos.asignacion(simboloObjetoGlob.GetNombre() + "." + simbolo.GetNombre(), simbolo_resultado.GetNombre()));
															tupla_Tercetos tupla_temp = new tupla_Tercetos(tabla.GetAmbitoActual(),terceto);
											 			    colaTercetos.add(tupla_temp);			   												
			   												}
			   											else
			   												{
															String terceto = new String(tercetos.asignacion(simbolo.GetNombre(), simbolo_resultado.GetNombre()));
															tupla_Tercetos tupla_temp = new tupla_Tercetos(tabla.GetAmbitoActual(),terceto);
											 			    colaTercetos.add(tupla_temp);	
			   												}
															
														.)
														puntoComa)
.

InstReturn <out int tipoDev>
(.	tipoDev = undef;
	int type;
	Simbolo simbolo_temp = null; .)
= 	   (.System.out.println("Entramos en InstReturn");
		 simboloClaseObjeto = null;
		 simbolo_temp = new Simbolo(tercetos.darEtiqueta(), undef, var);.)
(rreturn [VExpresion<out type, simbolo_temp> (.   System.out.println("Return devuelve un tipo:" + type);
									tipoDev= type; 
									hayreturn = true;.) ] puntoComa)
.

/****************************************************/

InstIfElse <Simbolo simbolo_funcion>	
(. int type, type1;
	Simbolo simbolo = null; //new Simbolo(t.val, 0, 0);	// borrarcuando corrigas
	Simbolo simbolo_temp = null;
.) 
=
		iff VExpresion<out type, simbolo_temp> (.if (type != bool) {SemErr("La condicion de un if debe ser logica");}
								  simbolo = new Simbolo ("IF", 0, 0);.) 
	((llave_ab (. tabla.NuevoAmbito(simbolo); .) Cuerpo<simbolo_funcion> (. tabla.CerrarAmbito();.) llave_ce) 
	//En caso de que no se habrán llaves no se abrirá un ámbito nuevo (no tiene ningún sentido)
	| Instruccion<simbolo_funcion> | ident (.
									 if (!(tabla.EstaRecur(t.val)))
									 	{
									 	SemErr(t.val + " no ha sido declarado previamente");
									 	}
									 else
									 	{
									 	simbolo = tabla.GetSimboloRecur(t.val);
										}
						.)
						InstExpresion <simbolo>
	) 
		 [Else <simbolo_funcion>]
.

Else<Simbolo simbolo_funcion>	(. int type;
	Simbolo sim = new Simbolo("ELSE", 0, 0);	// borrarcuando corrigas
.) 
=
	elsse ((llave_ab (. tabla.NuevoAmbito(sim); .) Cuerpo<simbolo_funcion> (. tabla.CerrarAmbito();.) llave_ce) 
			| Instruccion<simbolo_funcion>) .

/***************************************************/


/******************PRINT***********************/


InstCout
(. int type=undef; .)
=
	cout {menor_menor Arg_io<out type>} puntoComa (.if (type==undef) {
														SemErr("InstCout: Error tipos.");
													}.)
.

InstCin
(. int type; .)
=
	cin mayor_mayor Arg_io <out type> puntoComa
.

Arg_io<out int tipoDev>
(. tipoDev=undef;
   Simbolo sim = new Simbolo("Temp",0,0);
   Simbolo simbolo_temp = null; .)
=	ident (. if (!(tabla.EstaRecur(t.val)))
			 	SemErr(t.val + " no esta definido");
			 else if (sim.GetKind() == clase)
			 	SemErr(t.val + " es una clase");
			 else
			 	{
			 	sim = null;
			 	sim = tabla.GetSimboloRecur(t.val);
			 	tipoDev = sim.GetType();
			 	} .) 
		[(.Simbolo simbolo_lo_que_tiene_el_vector = new Simbolo(tercetos.darTemporal(),entera,var);.)
		DarPosVector <sim, simbolo_lo_que_tiene_el_vector>]
		| cadenaCar (. tipoDev = cadena; .)
		| VExpresion<out tipoDev, simbolo_temp>
.

DarPosVector <Simbolo sim, Simbolo simbolo_resultado> (.int tipoDev; .)
		= (.System.out.println("Estamos en DarPosVector");.)
			corchete_ab (.try
							{ 
							if (!(sim.Es_Vector()))
			 					SemErr(sim.GetNombre() + " definido en la linea " + sim.GetLine() + " columna " + sim.GetColumn() + " no es un vector");
			 				}
			 			catch (NullPointerException e)
			 				{
			 				System.out.println("Se le ha pasado un simbolo nulo a DarPosVector");
							}
			 			.)
			 			(.
			 			simbolo_resultado.SetType(entera);
			 			tabla.InsertarEnActual(simbolo_resultado);
			 			.)
 						enteros (. 
 								 if (Integer.parseInt(t.val) >= sim.Actualiza_Tamano())
 								 	SemErr("Posicion fuera de rango");
							   	 indice_vector = Integer.parseInt(t.val);
							   	 tercetos.elemento_vector(sim.GetNombre(), Integer.parseInt(t.val), simbolo_resultado.GetNombre());
								.)	 
 		corchete_ce
.


//******EXPRESIONES VERSIÓN DE VICTOR*************************************************************/

VExpresion <out int tipoDev, Simbolo simbolo_resultado> //Simbolo será el temporal donde se almacenara arriba el resultado de la expresion
=  (.System.out.println("Entramos en la nueva version de VExpresion");
	tipoDev=undef;
	int type=undef;
	Simbolo simbolo_op1=null;
	Simbolo simbolo_op2=null;
	String terceto;
	tupla_Tercetos tupla;.)
	
	(
	(. simbolo_op1 = new Simbolo(tercetos.darTemporal(),entera,var); .) 
	parent_ab VExpresion <out tipoDev, simbolo_resultado> parent_ce
	(. terceto = new String(tercetos.asignacion(simbolo_resultado.GetNombre(), simbolo_op1.GetNombre()));
	   tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
	   colaTercetos.add(tupla);
	.)
	 
	|
	
	 (. simbolo_op1 = new Simbolo(tercetos.darTemporal(),entera,var); .) 
	 VCambio_Signo <out tipoDev/*, simbolo_op1*/> 
	 (. terceto = new String(tercetos.asignacion(simbolo_resultado.GetNombre(), simbolo_op1.GetNombre()));
		tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
		colaTercetos.add(tupla);	 
	 .)
	 
	|
	 
	 (. simbolo_op1 = new Simbolo(tercetos.darTemporal(),bool,var); .) 
	 VNegacion <out tipoDev>
	 (. terceto = new String(tercetos.asignacion(simbolo_resultado.GetNombre(), simbolo_op1.GetNombre()));
		tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
		colaTercetos.add(tupla);	 
	 .)
	
	|

	 ValorFinalExp <out tipoDev, simbolo_resultado> 
	 
	 
	 								[VExpSuma <out type>		(. if ((tipoDev != entera) || (type != entera))
													 					SemErr("Error de tipos en la expresion");
						  						     			   else
															 			tipoDev=type;.)
					 				| VExpMul <out type>		(. if ((tipoDev != entera) || (type != entera))
															 			SemErr("Error de tipos en la expresion");
															 	   else
															 	   		tipoDev=type;.)
						 			| VExpAND <out type>		(. if ((tipoDev != bool) || (type != bool))
															 			SemErr("Error de tipos en la expresion");
																   else
															 	   		tipoDev=type;.)
						 			| VExpOR  <out type>		(. if ((tipoDev != bool) || (type != bool))
															 			SemErr("Error de tipos en la expresion");
																   else
															 	   		tipoDev=type;.)
						 			| VExpRelacional <out type> (. if ((tipoDev != entera) || (type != entera))
															 			SemErr("Error de tipos en la expresion");
															 	   else
															 	   		tipoDev = bool;.)
						 			]

)

 .



VCambio_Signo <out int tipoDev>
 = (. System.out.println("Entramos VCambio_Signo");
 	  int type = entera;
 	  tipoDev = undef;
 	  Simbolo simbolo_temp = null;
 	  if (t.val.contentEquals("+") || t.val.contentEquals("-") || t.val.contentEquals("/") ||t.val.contentEquals("*"))
 	  		SemErr("No esta permitido poner dos operandos seguidos. Sugerencia: defina mediante parentesis las expresiones");.)
 	op_menos (ValorFinalExp <out tipoDev, simbolo_temp> [VExpSuma <out type> | VExpMul <out type>] (. if ((tipoDev != entera) || (type != entera))
 																							SemErr("Error de tipos en la expresion");.) 
 			 | parent_ab VExpresion <out tipoDev, simbolo_temp> parent_ce (.if (tipoDev != entera)
 			 											   		SemErr("VCambio_Signo: Error de tipos en la expresion");.)
 			 
 			 )
 .

VNegacion <out int tipoDev>
 = (. System.out.println("Entramos VNegacion");
 	  int type = bool;
 	  tipoDev = undef;
 	  Simbolo simbolo_temp = null;.)
 	op_negacion (ValorFinalExp <out tipoDev, simbolo_temp> [VExpAND <out type> | VExpOR <out type>] (. if ((tipoDev != bool) || (type != bool))
 																							SemErr("Error de tipos en la expresion");.) 
 			 | parent_ab VExpresion <out tipoDev, simbolo_temp> parent_ce (.if (tipoDev != entera)
 			 											   		SemErr("VNegacion: Error de tipos en la expresion");.)
 			 
 			 )
 .
 
 VExpSuma <out int tipoDev>
  = (.System.out.println("Entramos VExpSuma");
  	  tipoDev=undef;
  	  Simbolo simbolo_temp = null;.)
    (op_mas | op_menos) VExpresion<out tipoDev, simbolo_temp> (.if (tipoDev != entera)
    											 		SemErr("VExpSuma: Error de tipos en la expresion");.)
    .
    
 VExpMul <out int tipoDev>
  = (. System.out.println("Entramos VExpMul");
  	   int type = entera;
  	   tipoDev = undef;
  	   Simbolo simbolo_temp = null;.)
    (op_producto | op_division) (ValorFinalExp<out tipoDev, simbolo_temp> [VExpSuma <out type> | VExpMul <out type>]
    					   		 | parent_ab VExpresion <out tipoDev, simbolo_temp> parent_ce) (. if ((tipoDev != entera) || (type != entera))
    					   													  			SemErr("ExpMul: Error de tipos en la expresion");.)
    .
    
 VExpAND <out int tipoDev>
  = (.System.out.println("Entramos VExpAND");
  	   int type = bool;
  	   tipoDev = undef;
  	   Simbolo simbolo_temp = null;.)
    (op_and (ValorFinalExp<out tipoDev, simbolo_temp> [VExpAND <out type> | VExpOR <out type>]
    					   		 | parent_ab VExpresion <out tipoDev, simbolo_temp> parent_ce) (. if ((tipoDev != bool) || (type != bool))
    					   		 														{
    					   		 														System.out.println(tipoDev + type);
    					   													  			SemErr("VExpAND: Error de tipos en la expresion");
    					   													  			}.)
    					   													  			
    					   	)
    .
    
 VExpOR <out int tipoDev>
  = (.System.out.println("Entramos VExpOR");
  	  tipoDev=undef;
  	  Simbolo simbolo_temp = null;.)
    (op_or) VExpresion<out tipoDev, simbolo_temp> (.if (tipoDev != bool)
      								 		SemErr("VExpoOR: Error de tipos en la expresion");.)
    .
    
 VExpRelacional <out int tipoDev>
 = (.System.out.println("Entramos VExpRelacional");
 	 tipoDev=undef;
 	 Simbolo simbolo_temp = null;.)
   (Operador_Relacional) VExpresion <out tipoDev, simbolo_temp> (.if (tipoDev != entera)
      								 					SemErr("VEXPRel: Error de tipos en la expresion");.)
   .

ValorFinalExp <out int tipoDev, Simbolo simbolo_resultado>
= (. tipoDev = undef;
	 Simbolo simbolo = null;
	 boolean esta = false;
	 int Pos_Vector;
	 int aux = 0;
	 System.out.println("Entramos en ValorFinalExp"); .)
	(ident (. if (!(tabla.EstaRecur(t.val)))
				{
				SemErr(t.val + " no estaba declarado previamente");
				}
			 else
				{
				//System.out.println("identificador ident!!"+t.val);
				simbolo = tabla.GetSimboloRecur(t.val);
				tipoDev = simbolo.GetType();
				//System.out.println("Tipo del ident!!"+tipoDev);
				simboloClaseObjeto = simbolo.GetClase();
				esta = true;
				}

			.)
	
	[((parent_ab (. if  (esta)			// Esto es la llamada a una funcion
				  		{
				  		tipoDev = simbolo.GetTipoRetorno();
				  		}
				  		
				  	if (simbolo.GetKind() != funcion)
					 	SemErr("'" + simbolo.GetNombre() + "' declarado en la linea " + simbolo.GetLine() + " no es una funcion");
				   .)
	 VArgumentos<simbolo, aux> parent_ce)
	 //Este es el caso de que sea un método o atributo de una clase 
	 | (punto ident (.Simbolo simbolo_metodoatributo = null;
	 				  Simbolo simbolo_clase = simbolo.GetClase();
	 				  TablaSimbolos ambitoclase;
	 				  if (simbolo_clase == null)
	 				  		SemErr("El identificador " + simbolo.GetNombre() + " no fue declarado como un objeto de ninguna clase.");
	 				  else
	 				  		{
	 				 		ambitoclase = simbolo_clase.GetAmbitoAsociado();
	 				 		 				 		
	 				 		if (!(ambitoclase.Esta(t.val)))
	 				 			SemErr(t.val + " no fue declarado dentro de la clase" + simbolo_clase.GetNombre());
	 				 		else
	 				 			{
	 				 			simbolo_metodoatributo = ambitoclase.GetSimbolo(t.val);
	 				 			simboloClaseObjeto = simbolo_metodoatributo.GetClase();
	 							if ((simbolo_metodoatributo.GetVisibilidad() == privado) &&
	 				 						(tabla.GetAmbitoActual().Ambito_Padre() != ambitoclase))	//Si el método o atributo es privado
	 				 							SemErr(t.val + " es de tipo privado");
	 				 			if (simbolo_metodoatributo.GetKind() == metodo)
	 				 				{
	 				 				tipoDev = simbolo_metodoatributo.GetTipoRetorno();
	 				 				if (!la.val.contentEquals("("))
	 				 					SemErr("Llamada invalida a metodo");
	 				 				}
	 				 			else if (simbolo_metodoatributo.GetKind() == var)
	 				 				{
	 				 				//System.out.println("EL TIPO DE " + simbolo_metodoatributo.GetNombre() +" ES " + simbolo_metodoatributo.GetType());
	 				 				String nombreatributo = new String (simbolo.GetNombre() + "." + simbolo_metodoatributo.GetNombre());
	 				 				System.out.println(nombreatributo);
	 				 				tipoDev = simbolo_metodoatributo.GetType();
	 				 				
	 				 				simbolo_resultado.SetType(entera);
  			   						String terceto;
  			   						terceto = tercetos.asignacion(simbolo_resultado.GetNombre(), nombreatributo);
  			   						tupla_Tercetos tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
  			  					 	colaTercetos.add(tupla);
  			   						tabla.InsertarEnActual(simbolo_resultado);
	 				 				
	 				 				}
	 				 			}
	 				  		}
	 				 .)
	 		  [parent_ab (. if (simbolo_metodoatributo.GetKind() != metodo) //Este es el caso de que sea un metodo
	 		  					SemErr(simbolo_metodoatributo.GetNombre() + " no fue declarado como un metodo");
	 		  				else
	 		  					{
	 		  					simboloClaseObjeto = simbolo_metodoatributo.GetClaseDevuelta();
	 		  					tipoDev = simbolo_metodoatributo.GetTipoRetorno();
	 		  					}
	 		  			  .)
	 		   VArgumentos <simbolo_metodoatributo, aux> parent_ce])
	 		  //CASO DE QUE SEA UN VECTOR
	 							   | (DarPosVector<simbolo, simbolo_resultado>) (.tipoDev=entera;
	 							   							   simbolo_resultado.SetType(entera);.))]
  

  | enteros (. tipoDev = entera;
  			   simbolo_resultado.SetType(entera);
  			   System.out.println("Esto es una prueba");
  			   String terceto;
  			   terceto = tercetos.asignacion_valor(simbolo_resultado.GetNombre(), Integer.parseInt(t.val));
  			   tupla_Tercetos tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
  			   colaTercetos.add(tupla);
  			   tabla.InsertarEnActual(simbolo_resultado);.)
  | ttrue 	(. tipoDev = bool;
			   simbolo_resultado.SetType(bool);
  			   String terceto;  			 
			   terceto = tercetos.asignacion_valor(simbolo_resultado.GetNombre(), 1);
			   tupla_Tercetos tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
			   colaTercetos.add(tupla);
			   tabla.InsertarEnActual(simbolo_resultado);.)
  | ffalse 	(. tipoDev = bool;
  			   simbolo_resultado.SetType(bool);
  			   String terceto;
			   terceto = tercetos.asignacion_valor(simbolo_resultado.GetNombre(), 0);
			   tupla_Tercetos tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
			   colaTercetos.add(tupla);
			   tabla.InsertarEnActual(simbolo_resultado);.)
  | cadenaCar (. tipoDev = cadena;
  				 simbolo_resultado.SetType(cadena);
  				 String terceto;
			   	 terceto = tercetos.asignacion(simbolo_resultado.GetNombre(), "\"" + t.val + "\"");
			   	 tupla_Tercetos tupla = new tupla_Tercetos(tabla.GetAmbitoActual(), terceto);
			   	 colaTercetos.add(tupla);
			   	 tabla.InsertarEnActual(simbolo_resultado);.))

.

VArgumentos <Simbolo simbolo, int pos>
= (. int type=undef;
	 Simbolo simbolo_nuevo = null; 
	 System.out.println("Entramos en VArgumentos");
	 Simbolo simbolo_temp = null;
	 	.)
[VExpresion<out type, simbolo_temp> (. if (simbolo != null)
							{
							if  (pos >= simbolo.GetNParametros())
											{
											SemErr("Numero de parametros no coincidente");
											}
										else
											{ 
											simbolo_nuevo = simbolo.GetParametros(pos);
											if (simbolo_nuevo.GetType() != type)
												SemErr("Tipo de los parametros no coincidente");
											}
							}
									  .)
["," VArgumentos <simbolo, pos + 1>]]
.

/**********************************************************/

Operador_Aritmetico = op_mas | op_menos | op_producto | op_division
.

Operador_Logico = op_or | op_and | op_negacion
.
				
Operador_Relacional = op_menor | op_mayor |   op_menor_igual
				| op_mayor_igual | op_igual | op_distinto
.

END CEMASMAS1.
