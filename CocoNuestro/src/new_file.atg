// Set the name of your grammar here (and at the end of this grammar):
COMPILER CEMASMAS

// Add auxiliary methods and declaration here.


// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit.
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.
  letter2		= 'A' .. 'Z' + 'a' .. 'z' + '_'.

  c1 			= ANY - "\"".
  c3 			= 'A' .. 'Z' + 'a' .. 'z' + '_' + digit.
  c4			= ANY - cr.
  c5			= ANY - "*".
  c6 			= ANY - "/".

TOKENS
  ident = letter { letter2 | digit }.


  enteros = ( zero | nonZeroDigit { digit }).
  
  cadenaCar = "\"" { c1 } "\"".


  bool = "boolean".
  charr    = "char".
  classs   = "class".
  false   = "false".
  intt     = "int".
  new     = "new".
  short   = "short".
  static  = "static".
  true    = "true".
  voidd    = "void".
  publicc = "public".
  privatte = "private".
  dospuntos_dos = "::".
  rreturn = "return".
  cout = "cout".
  cin = "cin".
  menor_menor = "<<".
  mayor_mayor = ">>".
  iff = "if".
  elsse = "else".
  main = "main".
  
  
  dosPuntos   = ":".
  comma   = ",".
  punto     = ".".
  llave_ab  = "{".
  corchete_ab  = "[".
  parent_ab    = "(".
  op_menos   = "-".
  op_menosmenos   = "--".  
  op_not     = "!".
  op_mas    = "+".
  op_masmas = "++".
  llave_ce  = "}".
  corchete_ce  = "]".
  parent_ce    = ")".
  op_producto	= "*".
  op_division		= "/".
  op_menor			= "<".
  op_mayor			= ">".
  op_menor_igual = "<=" .
  op_mayor_igual = ">=" .
  op_igual			= "==".
  op_asig           = "=".
  puntoComa			= ";".
  doblesComillas	= '"'.
  interrogacion		= "?".
  barra_vert = "|".
  op_distinto = "!=".
  op_and = "&&".
  op_asig_mas = ":=+".
  op_or = "||".
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE lf + cr + tab



//PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .

// Punto de entrada del codigo fuente, acabará SIEMPRE en un MAIN
CEMASMAS = DecClase CEMASMAS
			 | (Ttipo (Main | ident (Subprograma | DecVar | DecMetodo) CEMASMAS)).

Ttipo = 	// Booleano necesario para eliminar
	(intt						// errores con declaracion de globales
	| bool
	| voidd
	| charr [op_producto]).// cadena de caracteres
//	| ident // si es un ttipo de variable puede ser IDENT, e.o.c. NO


DecClase = classs ident llave_ab [DecCabMet]
		{[(publicc | privatte) dosPuntos DecCabMet] puntoComa} llave_ce puntoComa.

DecCabMet = Ttipo ident ( {comma ident} | (parent_ab [Ttipo {comma Ttipo}] parent_ce)).

DecMetodo = dospuntos_dos ident parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.

Main = main parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.

Cuerpo = {Instruccion | Ttipo ident (Subprograma2 | DecVar)}.

Cuerpo2 = {Instruccion | Ttipo ident (DecVar)}.
//El apéndice del final indica el nivel de anhidamiento.

DecVar = [op_asig Expresion] puntoComa.

Parametros = Ttipo ident [{comma Ttipo ident}].

Subprograma = parent_ab [Parametros] parent_ce llave_ab Cuerpo llave_ce.

Subprograma2 = parent_ab Parametros parent_ce llave_ab Cuerpo2 llave_ce.
//El apendice del final indica el nivel de anhidamiento


/******************INSTRUCCIONES*****************************/
Instruccion = InstReturn | InstCout | InstCin | InstExpresion.

InstExpresion = ident (op_asig) Expresion puntoComa.

InstReturn = (rreturn [Expresion] puntoComa).

InstCond = .

InstCout = cout {menor_menor Arg_io} puntoComa.

InstCin = cin mayor_mayor Arg_io puntoComa.

Arg_io = ident | cadenaCar.



/******************EXPRESIONES*****************************/


Expresion = Expresion2 Expresion1	
.

Expresion1 = ["?" Expresion ":" Expresion Expresion1]
.

Expresion2 = Expresion3 Expresion21
.

Expresion21 = ["<" Expresion3 Expresion21]
.

Expresion3 = Expresion4 Expresion31
.

Expresion31 = ["+" Expresion4 Expresion31]
.

Expresion4 = "!" Expresion4
|Expresion5
.

/* Expresion 5 recoge todos los siguientes supuestos:

			Constructor
			ident
			ident.ident
			ident (Argumentos)
			enteros
			Todas aquellas Expresiones que contienen los siguientes operadores
					
							Aritméticos (+)
							Relación    (<)
							Lógicos   	(!)  
							Asignacion 	(=)
							Condicional
							Acceso a miembros de una clase (.)
							Acceso a un vector ([])
							
*/

Expresion5 = "(" Expresion ")"
| "new" ident "("Argumentos")"       /*Constructor*/
| ident ["."ident ["("Argumentos")"] | "("Argumentos")"| "["Expresion"]"]
| enteros
| cadenaCar
| "true"
| "false"
.

/**********************************************************/

Argumentos = [Expresion {"," Argumentos}].


Operador = op_mas | op_menos | op_producto | op_division.



END CEMASMAS.